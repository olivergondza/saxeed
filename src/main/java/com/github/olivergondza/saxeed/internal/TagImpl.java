package com.github.olivergondza.saxeed.internal;

import com.github.olivergondza.saxeed.Tag;
import org.xml.sax.Attributes;

import java.util.*;
import java.util.function.Consumer;
import java.util.stream.Collectors;

/**
 * The Element representation for the purposes of visiting.
 *
 * It provides accessors to element data, and mutator methods for a visitor to communicate the decision of what to write.
 *
 * Implementation note: The actual class is hidden for client to only use the interface(s). This has dedicated
 * sub-interfaces for Visitor call argument, but the exact same instance is passed. The point is to provide a compile-time
 * guarantee that methods that are called as certain stage can legally be called. IOW, when closing tag, method modifying
 * attributes will nt be available.
 */
/*package*/ class TagImpl implements
        Tag, Tag.Start, Tag.End
{

    private /*almost final*/ TagImpl parent;

    private final String name;
    private final Attributes attrs;

    /**
     * The element is not part of the input stream, but it has been generated by a visitor.
     */
    private final boolean generated;

    /**
     * Possibly modified list of attributes.
     *
     * Preserve insertion order.
     */
    private LinkedHashMap<String, String> attributes;

    /**
     * Modifiable indication of tag write/delete.
     */
    private TagWriteMode writeMode = TagWriteMode.WRITE;

    /**
     * List of children to be added.
     */
    private final List<TagImpl> childrenToAdd = new ArrayList<>();

    /**
     *  Element that current element should be surrounded with.
     */
    private TagImpl wrapWith;

    /**
     * Create generated Tag.
     */
    private TagImpl(TagImpl parent, String name) {
        init(parent);
        this.name = name;
        this.attrs = null; // No SAX attrs, setting attributes right away
        this.attributes = new LinkedHashMap<>();
        this.generated = true;
    }

    /**
     * Create Tag from input.
     */
    public TagImpl(TagImpl parent, String name, Attributes attrs) {
        init(parent);
        this.name = name;
        this.attrs = attrs;
        this.generated = false;
    }

    private void init(TagImpl parent) {
        this.parent = parent;

        // Inherit the write mode based on the parent's one.
        if (parent != null) {
            writeMode = parent.writeMode.children;
        }

        // Verify invariant
        traverseParentChain(null);
    }

    @Override
    public Map<String, String> getAttributes() {
        if (attributes == null) {
            attributes = new LinkedHashMap<>(attrs.getLength());
            for (int i = 0; i < attrs.getLength(); i++) {
                attributes.put(attrs.getQName(i), attrs.getValue(i));
            }
        }

        return attributes;
    }

    @Override
    public boolean isNamed(String name) {
        return Objects.equals(name, this.name);
    }

    @Override
    public boolean isGenerated() {
        return generated;
    }

    // This returns the most restricted interface as the parent have always been written.
    @Override
    public Tag getParent() {
        return parent;
    }

    @Override
    public String getName() {
        return name;
    }

    @Override
    public Tag getParent(String name) {
        return parent != null && parent.isNamed(name) ? parent : null;
    }

    @Override
    public Tag getAncestor(String name) {
        for (TagImpl tag = this.parent; tag != null; tag = tag.parent){
            if (tag.isNamed(name)) return tag;
        }
        return null;
    }

    @Override
    public TagImpl addChild(String name) {
        TagImpl child = new TagImpl(this, name);
        childrenToAdd.add(child);
        return child;
    }

    @Override
    public TagImpl wrapWith(String name) {
        this.wrapWith = new TagImpl(parent, name);
        return this.wrapWith;
    }

    /**
     * Decide if this element should be written or not.
     */
    @Override
    public boolean isOmitted() {
        return !writeMode.writeMe;
    }

    /*package*/ boolean isCharactersOmitted() {
        return !writeMode.writeText;
    }

    @Override
    public void skip() {
        writeMode = TagWriteMode.SKIP;
    }

    @Override
    public void unwrap() {
        writeMode = TagWriteMode.UNWRAP;
    }

    @Override
    public void empty() {
        writeMode = TagWriteMode.EMPTY;
    }

    @Override
    public boolean removeAttributes(Collection<String> attrs) {
        return getAttributes().keySet().removeAll(attrs);
    }

    @Override
    public String removeAttribute(String attr) {
        return getAttributes().remove(attr);
    }

    /*package*/ List<TagImpl> getTagsAdded() {
        return childrenToAdd;
    }

    // The hierarchy of tag parents needs to be fixed as we have injected a new one
    // between `this` and `this.parent`
    /*package*/ TagImpl startWrapWith() {
        // Noop if not configured
        if (wrapWith == null) return null;

        TagImpl newParent = wrapWith;

        if (this.parent != null) {

            if (newParent.parent != this.parent) throw new AssertionError(
                    "Unable to set parent, invalid grandparent:" +
                            "\n  this:        " + this.getName() +
                            "\n  this.parent: " + (this.parent == null ? null : this.parent.name) +
                            "\n  new:         " + newParent.getName() +
                            "\n  new.parent:  " + (newParent.parent == null ? null : newParent.parent.name)
            );

            traverseParentChain(tag -> {
                if (tag == newParent) throw new AssertionError(
                        String.format("Cannot insert parent %s. Already in %s", newParent.getName(), this)
                );
            });
        }

        this.parent = newParent;
        return newParent;
    }

    /*package*/ TagImpl endWrapWith() {
        TagImpl old = this.wrapWith;
        this.wrapWith = null;
        return old;
    }

    public String toString() {
        StringBuilder sb = new StringBuilder();
        traverseParentChain(t -> {
            // the hierarchy is iterated backwards. To produce hierarchy from root, it is prepending to the beginning of the builder.
            sb.insert(0, ">");
            if (t.isOmitted()) {
                sb.insert(0, "(omitted)");
            }
            if (t.isGenerated()) {
                sb.insert(0, "(generated)");
            }
            sb.insert(0, t.getName());
        });
        return sb.toString();
    }

    /**
     * Traverse parent hierarchy from current to root, reporting problems.
     *
     * @param consumer Optional operation to apply to each.
     */
    private void traverseParentChain(Consumer<TagImpl> consumer) {
        LinkedHashSet<TagImpl> chain = new LinkedHashSet<>();
        TagImpl tag = this;
        for (int depth = 0; depth < 100; depth++) {
            boolean found = !chain.add(tag);
            if (found) throw new AssertionError(
                    "Duplicate parent found " + tag.getName() + " in " + printChain(chain)
            );

            if (consumer != null) {
                consumer.accept(tag);
            }

            tag = tag.parent;
            if (tag == null) return;
        }

        throw new AssertionError("Too deap of a parent loop: " + printChain(chain));
    }

    private String printChain(LinkedHashSet<TagImpl> chain) {
        List<String> names = chain.stream()
                .map(TagImpl::getName)
                .collect(Collectors.toList())
        ;
        Collections.reverse(names);
        return String.join(">", names);
    }
}
