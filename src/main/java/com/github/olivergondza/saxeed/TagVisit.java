package com.github.olivergondza.saxeed;

import org.dom4j.Element;
import org.xml.sax.Attributes;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;

/**
 * The Element representation for the purposes of visiting.
 *
 * It provides accessors to element data, and mutator methods for a visitor to communicate the decision of what to write.
 */
public final class TagVisit {
    enum WriteTag {
        WRITE, SKIP, SKIP_RECURSIVELY;
    }

    public /*almost final*/ TagVisit parent;

    private final String name;
    private final Attributes attrs;

    /**
     * The element is not part of the input stream, but it has been generated by a visitor.
     */
    private final boolean generated;

    // Possibly modified list of attributes
    private Map<String, String> attributes;

    // Modifiable indication of tag write/delete
    private WriteTag writeTag = WriteTag.WRITE;

    // Modifiable indication of file delete
    private TransformationHandler.DeleteFileException deleteFile = null;

    // List of tags to be added to the output document
    private final List<Element> tagsAdded = new ArrayList<>();

    // Element that current element should be surrounded with.
    private Element surroundWith;

    TagVisit(TagVisit parent, String name, Attributes attrs) {
        this(parent, name, attrs, false);
    }

    TagVisit(TagVisit parent, String name, Attributes attrs, boolean generated) {
        this.parent = parent;
        this.name = name;
        this.attrs = attrs;
        this.generated = generated;

        // Skipping recursively needs to be inherited to children
        if (parent != null && parent.writeTag == WriteTag.SKIP_RECURSIVELY) {
            writeTag = parent.writeTag;
        }
    }

    public Map<String, String> getAttributes() {
        if (attributes == null) {
            attributes = new HashMap<>(attrs.getLength());
            for (int i = 0; i < attrs.getLength(); i++) {
                attributes.put(attrs.getQName(i), attrs.getValue(i));
            }
        }

        return attributes;
    }

    public boolean isNamed(String name) {
        return Objects.equals(name, this.name);
    }

    public boolean isGenerated() {
        return generated;
    }

    public TagVisit getParent() {
        return parent;
    }

    public String getName() {
        return name;
    }

    public List<Element> getTagsAdded() {
        return tagsAdded;
    }

    public Element getSurroundWith() {
        return surroundWith;
    }

    public TagVisit parent(String name) {
        return parent != null && parent.isNamed(name) ? parent : null;
    }

    public TagVisit ancestor(String name) {
        for (TagVisit tag = this.parent; tag != null; tag = tag.parent){
            if (tag.isNamed(name)) return tag;
        }
        return null;
    }

    public boolean removeAttributes(Collection<String> attrs) {
        return getAttributes().keySet().removeAll(attrs);
    }

    public String removeAttribute(String attr) {
        return getAttributes().remove(attr);
    }

    public void addChildren(List<Element> children) {
        tagsAdded.addAll(children);
    }

    public void addChild(Element child) {
        tagsAdded.add(child);
    }

    public void addSurroundingElement(Element surroundWith) {
        if (this.surroundWith != null) throw new AssertionError("Unable to surround with multiple elements. Existing " + surroundWith);

        this.surroundWith = surroundWith;
    }

    public void skipRecursively() {
        writeTag = WriteTag.SKIP_RECURSIVELY;
    }

    public void skip() {
        writeTag = WriteTag.SKIP;
    }

    public boolean isSkipped() {
        return writeTag != WriteTag.WRITE;
    }
}
